#add distance traveled
travelDist = travelDist + cityData[i,d]
# add to visited list
v <- c(v,i)
print("out")
}
#make destination city the starting point
i = d
#find closest city
d = which.min(cityData[i,])
#add distance traveled
travelDist = travelDist + cityData[i,d]
# add to visited list
v <- c(v,i)
print("in")
}
v
travelDist = 0
visited <- list()
i =  sample(1:10, 1) #initalize a random starting point
destination = which.min(cityData[i,]) #use a greedy method and find closest city
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
# add to visited list
visited <- c(visited,i,destination)
visited
i
destination
i =  sample(1:10, 1) #initalize a random starting point
visited <- c(i)
visited
i
travelDist = 0
i =  sample(1:10, 1) #initalize a random starting point
while (TRUE){
visited <- c(i)
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% vistited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
travelDist = 0
i =  sample(1:10, 1) #initalize a random starting point
while (TRUE){
visited <- c(i)
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
visited
i
travelDist = 0
i =  sample(1:10, 1) #initalize a random starting point
visited <- c(i)
i
visited
length(visited)
while (length(visited)<11){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
visited
travelDist = 0
i =  sample(1:10, 1) #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
visited
which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
travelDist = 0
i =  sample(1:10, 1) #initalize a random starting point
visited <- c(i)
i
destination = which.min(cityData[i,])
destination
if (destination %in% visited)
destination %in% visited
destination %in% visited
visited <- c(visited, destination)
visited
travelDist = travelDist + cityData[i,destination]
travelDis
travelDist
i = destination
i
which.min(cityData[i,])
destination = which.min(cityData[i,])
destination %in% visited
visited <- c(visited, destination)
visited
travelDist = travelDist + cityData[i,destination]
travelDist
i = destination
i
which.min(cityData[i,]
which.min(cityData[i,])
which.min(cityData[i,])
destination = which.min(cityData[i,])
destination %in% visited
which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
visited <- c(visited, destination)
length(visited)
travelDist = travelDist + cityData[i,destination]
i = destination
i
which.min(cityData[i,])
destination = which.min(cityData[i,])
destination %in% visited
which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
travelDist = 0
i =  sample(1:10, 1) #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
visited
travelDist = 0
i =  sample(1:10, 1) #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
visited
# optimize two values to match the starting point that minimizes the travelDist and pi
evaluate <- function(string=c()) {
returnVal = NA;
if (length(string) == 2) {
#TSP Part
travelDist = 0
i =  as.integer(string[1]) #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
returnVal = abs(travelDist-0) + abs(string[2]-pi);
} else {
stop("Expecting a chromosome of length 2!");
}
returnVal
}
rbga.results = rbga(stringMin=c(1, 1), stringMax=c(10, 4), popSize = 200,
evalFunc=evaluate, verbose=TRUE, mutationChance=0.01)
plot(rbga.results)
rbga.results
summary.rbga(rbga.results)
genalg:::summary.rbga(rbga.results)
help("rbga")
summary(rbga.results)
plot(rbga.results) # convergence
plot(rbga.results, type="hist")
plot(rbga.results, type="vars")
require(genalg) # minmizing algorithm
# not using bits (1,0) now using floating points - we just have a two gene chromosome
# optimize two values to match pi and sqrt(50)
evaluate <- function(string=c()) {
returnVal = NA;
if (length(string) == 2) {
returnVal = abs(string[1]-pi) + abs(string[2]-sqrt(50));
} else {
stop("Expecting a chromosome of length 2!");
}
returnVal
}
monitor <- function(obj) {
# plot the population
xlim = c(obj$stringMin[1], obj$stringMax[1]);
ylim = c(obj$stringMin[2], obj$stringMax[2]);
plot(obj$population, xlim=xlim, ylim=ylim,
xlab="pi", ylab="sqrt(50)");
}
rbga.results = rbga(stringMin=c(1, 1), stringMax=c(5, 10), popSize = 200, monitorFunc=monitor,
evalFunc=evaluate, verbose=TRUE, mutationChance=0.01)
plot(rbga.results) # convergence
plot(rbga.results, type="hist")
plot(rbga.results, type="vars")
rbga.results
library(datasets) # where UScitiesD is
library(genalg)
# Attempt at solving the Traveling Salesman Problem...couldn't figure it out, so
# I'm going to use the starting point value as a chromosome in the GA.
#data for the TSP
cityData <- as.matrix(UScitiesD)
cityData[cityData<1] <- 9999 #change diagonals from 0 to 9999 so the min calculation works later
# optimize two values to match the starting point that minimizes the travelDist and pi
evaluate <- function(string=c()) {
returnVal = NA;
if (length(string) == 2) {
#TSP Part
travelDist = 0
i =  as.integer(string[1]) #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
returnVal = abs(travelDist-0) + abs(string[2]-pi);
} else {
stop("Expecting a chromosome of length 2!");
}
returnVal
}
rbga.results = rbga(stringMin=c(1, 1), stringMax=c(10, 4), popSize = 200,
evalFunc=evaluate, verbose=TRUE, mutationChance=0.01)
rbga.results
travelDist = 0
i =  3 #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
\
travelDist
travelDist = 0
i =  3 #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
visited
travelDist = 0
i =  3 #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
#next closest city could still be in visited, so go to furthest city
if (destination %in% visited){
destination = which.max(cityData[i,])
}
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
visited
i =  3 #initalize a random starting point
visited <- c(i)
destination = which.min(cityData[i,])
destination
destination %in% visited
visited <- c(visited, destination)
visited
travelDist = travelDist + cityData[i,destination]
i = destination
i
destination = which.min(cityData[i,])
destination
destination %in% visited
visited <- c(visited, destination)
travelDist = travelDist + cityData[i,destination]
i = destination
i
destination = which.min(cityData[i,])
destination
destination %in% visited
which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
destination %in% visited
i =  3 #initalize a random starting point
visited <- c(i)
destination = which.min(cityData[i,])
visited <- c(visited, destination)
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
i
destination = which.min(cityData[i,])
destination
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
i
destination = which.min(cityData[i,])
destination
destination %in% visited
which.min(cityData[i,][cityData[i,]>cityData[i,destination]]) + 1
travelDist = 0
i =  3 #initalize a random starting point
visited <- c(i)
while (length(visited)<10){
#use a greedy method and find closest city
destination = which.min(cityData[i,])
#if we've already been to that city
if (destination %in% visited){
#find next closest city
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]]) + 1
#next closest city could still be in visited, so go to furthest city
#if (destination %in% visited){
#  destination = which.max(cityData[i,])
#}
}
#add destination to visited list
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
}
visited
i =  3 #initalize a random starting point
visited <- c(i)
destination = which.min(cityData[i,])
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
destination = which.min(cityData[i,])
visited <- c(visited, destination)
#add that distance to the city to the total distance traveled
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
i
destination = which.min(cityData[i,])
destination %in% visited
destination = which.min(cityData[i,][cityData[i,]>cityData[i,destination]]) + 1
visited <- c(visited, destination)
visited
travelDist = travelDist + cityData[i,destination]
#change starting point
i = destination
i
destination = which.min(cityData[i,])
destination
destination %in% visited
which.min(cityData[i,][cityData[i,]>cityData[i,destination]])
## A small example with a data set created artificially from the IRIS
## data
data(iris)
data <- iris[, c(1, 2, 5)]
data$Species <- factor(ifelse(data$Species == "setosa","rare","common"))
## checking the class distribution of this artificial data set
table(data$Species)
## now using SMOTE to create a more "balanced problem"
newData <- SMOTE(Species ~ ., data, perc.over = 600,perc.under=100)
table(newData$Species)
install.packages(DMwR)
install.packages("DMwR")
library(DMwR)
## A small example with a data set created artificially from the IRIS
## data
data(iris)
data <- iris[, c(1, 2, 5)]
data$Species <- factor(ifelse(data$Species == "setosa","rare","common"))
## checking the class distribution of this artificial data set
table(data$Species)
## now using SMOTE to create a more "balanced problem"
newData <- SMOTE(Species ~ ., data, perc.over = 600,perc.under=100)
table(newData$Species)
## Checking visually the created data
## Not run:
par(mfrow = c(1, 2))
plot(data[, 1], data[, 2], pch = 19 + as.integer(data[, 3]),
main = "Original Data")
plot(newData[, 1], newData[, 2], pch = 19 + as.integer(newData[,3]),
main = "SMOTE'd Data")
## End(Not run)
## Now an example where we obtain a model with the "balanced" data
classTree <- SMOTE(Species ~ ., data, perc.over = 600,perc.under=100,
learner='rpartXse',se=0.5)
## check the resulting classification tree
classTree
## The tree with the unbalanced data set would be
rpartXse(Species ~ .,data,se=0.5)
# Install
install.packages("tm")  # for text mining
install.packages("SnowballC") # for text stemming
install.packages("wordcloud") # word-cloud generator
install.packages("RColorBrewer") # color palettes
# Load
library("tm")
library("SnowballC")
library("wordcloud")
library("RColorBrewer")
setwd("~/Documents/MSDS/DSI-Religion-2017/sampleSignals")
# Dorothy Day
DaynoPro <- read.csv("DorothyDay-3AS-KEYWORDS-tfidfNoPro.csv")
DaytfIdf <- read.csv("DorothyDay-2CD-KEYWORDS-tfidf.csv")
DayadjAdv <- read.csv("DorothyDay-62Z-KEYWORDS-adjAdv.csv")
wordcloud(words = DaynoPro$term, freq = DaynoPro$logtfidf, min.freq = 1,
max.words = 100, random.order = FALSE, rot.per=0.00, random.color = TRUE,
colors = c("darkorange3", "royalblue4"))
wordcloud(words = DaytfIdf$term, freq = DaytfIdf$logtfidf, min.freq = 1,
max.words = 100, random.order = FALSE, rot.per=0.00, random.color = TRUE,
colors = c("darkorange3", "royalblue4"))
wordcloud(words = DayadjAdv$word, freq = DayadjAdv$count, min.freq = 1,
max.words = 100, random.order = FALSE, rot.per=0.00, random.color = TRUE,
colors = c("darkorange3", "royalblue4"))
